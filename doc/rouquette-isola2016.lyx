#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass llncs
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Simplifying OMG MOF-based Metamodeling
\end_layout

\begin_layout Author
Dr.
 Nicolas F.
 Rouquette
\end_layout

\begin_layout Institute
Jet Propulsion Laboratory, California Institute of Technology
\end_layout

\begin_layout Abstract
What is a metamodel? 
\begin_inset Quotes eld
\end_inset

A metamodel is a model used to model modeling itself.
\begin_inset Quotes erd
\end_inset

 Although this definition from the Meta-Object Facility (MOF) Core 2.5 specificat
ion lacks clarity, it is reflective of a cultural mindset about the relationship
 between models and metamodels.
 This paper proposes a different perspective about this relationship; briefly,
 equating a metamodel for a modeling language to the specification of a
 fourth normal form relational schema for the abstract syntax of that language
 and equating a model written in a modeling language to tabular data conforming
 to the relational schema of that language.
 
\end_layout

\begin_layout Abstract
The essence of defining a fourth-normal relational schema for metamodel
 involves three kinds of tables: entity tables for each metaclass, directed
 binary relational tables for each association among metaclasses and attribute
 tables for each datatyped property.
 With a strict separation of modeling concerns amongst entities, relations
 and attributes tables, it is possible to explain traditional MOF-based
 metamodeling in a simpler way where metaclasses correspond to entity tables
 and associations correspond to relation tables as if they were directed
 and owned both of their association end properties.
 More importantly, this paper explains that this paradigm shift brings three
 tangible benefits for the practice of metamodeling at large: First, in
 lieu of a reflexive, multi-level metamodeling architecture like MOF where
 the notion of a profile seems to straddle between the metamodel and model
 levels, this paper explains a simpler paradigm from the perspective of
 equating a metamodel to the ontology of a terminology vocabulary and of
 using ontology terminology refinement as the basis for multi-level (meta)
 modeling.
 Second, in lieu of a complex model interchange paradigm based on serializing
 models using the XML Metadata Interchange (XMI) standard, this paper explains
 the benefits of serializing models in terms of their irreducible content
 as normal form relational data.
 Finally, this paper explains that the focus on normalizing the information
 schema of a model works in tandem with leveraging recent advances in functional
 programming languages like Scala to modernize the traditional practice
 of model-based programming with the Object Constraint Language (OCL) and
 the Query/View/Transformation (QVT) standards.
\end_layout

\begin_layout Section
MOF-based metamodeling is too complex
\end_layout

\begin_layout Standard
Several factors contribute to the complexity of MOF as an incomplete architectur
e for metamodeling and modeling with poorly separated concerns.
 The most significant factor pertains to the fundamental modeling constructs
 in the MOF architecture, alasses, associations and properties; and more
 specifically to their lack of orthogonality since an association can be
 modeled as a class with a pair of properties.
 In practice, poor separation of concerns between entity and relationship
 constructs invites significant conceptual redundancy and variability in
 their use.
 For example, a relationship among entities may be modeled via several patterns
 of fundamental constructs: as an association (with association end properties),
 as properties of the related entities (without an association), as a (relations
hip) class with properties or as even more redundant combinations of the
 above.
 Since the Object Management Group (OMG) uses MOF for defining metamodels,
 construct redundancy affects all OMG metamodels like the Unified Modeling
 Language (UML) where redundancy leads to significant variability in the
 way conceptual relationships are defined in the UML metamodel.
\end_layout

\begin_layout Standard
The UML metamodel is defined in terms of MOF classes, associations and propertie
s.
 A MOF class in a metamodel for a modeling langauge represents a concept
 in that language.
 There is no terminology consensus for what MOF associations and properties
 represent in the modeling language.
 The metaclasses in the UML metamodel are organized in a classification
 taxonomy with a single root metaclass, UML Element, which is the toplevel
 concept in UML for a constituent of a model.
 All the other metaclasses in the UML metamodel are directly or indirectly
 classified as a kind of UML Element.
 For example, a UML Relationship is a kind of UML Element specifying some
 kind of relationship between other UML Elements.
 Unfortunately, The UML Relationship metaclass does not classify all of
 the UML metaclasses that conceptually represent some kind of relationship
 in the language, for example:
\end_layout

\begin_layout Enumerate
In the graph of a UML Activity, the ActivityEdge metaclass represents a
 directed relationship from an ActivityNode to another.
\end_layout

\begin_layout Enumerate
In the graph of a UML Interaction, the GeneralOrdering metaclass represents
 a directed relationship from an OccurrenceSpecification to another.
\end_layout

\begin_layout Enumerate
In the graph of a UML Interaction, the Message metaclass represents a trace
 relationship between send and receive events.
\end_layout

\begin_layout Enumerate
In the graph of a UML StateMachine, the Transition metaclass represents
 a directed relationship from a Vertex to another.
 
\end_layout

\begin_layout Enumerate
In the graph of a UML StructuredClassifier, the Connector metaclass represents
 a join relationship among ConnectorEnds.
\end_layout

\begin_layout Standard
In all five examples, the conceptual relationship is represented as a metaclass;
 however, these examples differ in the way related entities are represented.
 For ActivityEdge (1) and GeneralOrdering (2), each related entity is represente
d as an undirected association with non-derived class-owned association
 end properties.
 This is done differently for the other cases (3,4,5): The representation
 of the source and target vertices of a Transition (4) is closest to (1)
 and (2) except that the association end property typed by the relationship
 itself is derived in (4) compared to (1) and (2) where it isn't.
 The representation of the send and receive events of a Message (3) involves
 a directed association from the relationship metaclass (Message) to the
 related entity metaclass (MessageEnd).
 This is in contrast to (1,2,4) where the association is undirected.
 Finally, the representation of the related ConnectorEnds for a Connector
 (5) involves a single undiferentiated directed composite association unlike
 all other cases (1,2,3,4) where the relating association is non-composite.
 Although there are legitimate syntactic concerns behind the variability
 of these five cases, the lack of syntactic homogeneity in the way conceptual
 relationships are represented in the UML constitutes a significant source
 of metamodeling complexity.
\end_layout

\begin_layout Standard
This paper argues that the root cause of metamodeling complexity stems from
 a design choice to provide support for syntactically representing characteristi
cs of conceptual relationships that have subtle interdependencies:
\end_layout

\begin_layout Itemize
The syntactic variability of association end property ownership (association-own
ed vs metaclass-owned) affects property subsetting and redefinition since
 the subsetting and redefinition contexts respectively are different in
 each case.
\end_layout

\begin_layout Itemize
Syntactically, property characteristics such as ownership, aggregation,
 derivation, subsetting and redefining are independent of each other.
 However, the syntactic coupling of properties as opposites of a binary
 association end forces subtle restrictions on well-formed syntactic variations.
 These subtilities were poorly understood from UML 2.0 until UML 2.3.
 A key goal of the MOF 2.4 and UML 2.4 revisions was to formalize the well-formedn
ess constraints applicable to all MOF metamodels and to verify the well-formedne
ss of UML 2.4.
 Achieving this goal involved hundreds of repairs; far too many to manually
 review so special tools were required to mechanically verify them.
 However, a subtle error slipped through all reviews that required an urgent
 fix and the publication of UML 2.4.1
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
target "https://blogs.msdn.microsoft.com/stevecook/2011/10/24/uml-2-4-1-now-released/"

\end_inset


\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Quote
When UML 2.4 was released we discovered an issue that meant it was impossible
 to interchange StructuredActivityNodes reliably.
 StructuredActivityNodes are executable nodes in an activity diagram that
 are also groups.
 UML 2.4 doesn’t specify clearly whether they should be serialized as nodes
 or as groups; as a consequence, different tools do different things.
 In UML 2.4.1 this ambiguity is remedied by serializing them in their own
 collection.
 UML 2.4.1 can be found at http://www.omg.org/spec/UML/2.4.1/ and all of the machine-r
eadable files are at http://www.omg.org/spec/UML/20110701/.
\end_layout

\begin_layout Quote
This is the first time in the history of UML that a complete machine-readable
 definition of the language is available online, defined as an instance
 of itself, and with no dangling references.
 Only of interest to UML aficionados maybe, but a milestone nonetheless.
\end_layout

\end_deeper
\begin_layout Standard
Surprisingly, although the OMG positioned MOF as an architecture for defining
 and managing metadata information, there is no evidence in the OMG specificatio
ns to suggest that the proven principles of information modeling with the
 relational model were taken into consideration, if at all.
 This paper departs from the traditional object-oriented modeling & programming
 perspective that influenced the original definition of UML1 and the major
 revision in UML2.
 Notwithstanding considerations of normalization in relational modeling
 as a pragmatic criteria for simplifying the current MOF paradigm, there
 is plenty of historical evidence in the records of OMG task forces about
 the difficulties encountered in understanding the particular patterns of
 fundamental constructs used in specifying a metamodel or a profile and
 in correcting errors due to differences between the intended and the actual
 meaning of the abstract syntax according to the OMG task force vs.
 the patterns of MOF fundamental constructs used.
 Historically, the cost of finding and correcting these discrepancies has
 been very high in terms of the man/years of effort by OMG task forces and
 by tool vendors implementing revisions of OMG specifications.
 Experience suggests that the current OMG processes for revising OMG specificati
ons incur significant missed opportunity costs because of the lack of pragmatic
 rigor in exploiting modern computer science techniques for rigorous specificati
on development, for example:
\end_layout

\begin_layout Itemize
Formal methods help ensure that a system behaves according to its specification.
 
\end_layout

\begin_deeper
\begin_layout Standard
How about verifying that a system (e.g.
 an implementation of a modeling language like the UML) behaves according
 to its specification (e.g., the OMG UML abstract syntax metamodel)?
\end_layout

\end_deeper
\begin_layout Itemize

\shape italic
A type system is a tractable syntactic method for proving the absence of
 certain program behaviors by classifying phrases according to the kinds
 of values they compute
\begin_inset CommandInset citation
LatexCommand cite
key "TypesAndProgrammingLanguages"

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
The OMG publishes several modeling specifications with executable semantics
 such as Alf & fUML and BPMN.
 Alf is an example of a recently developed specification at the OMG where
 the Alf modeling language is specified in the same fashion as programming
 languages are, that is, with an explicitly defined type system.
 Alf is an exception at the OMG.
 
\end_layout

\end_deeper
\begin_layout Standard
In particular, it is noteworthy to emphasize that the OMG publication process
 requires every OMG modeling specification to specify criteria of conformance
 to the specification.
 Such criteria pertain to notions of abstract and concrete syntax, model
 interchange, diagram interchange and semantics.
 Historically, this process requirement has received very little attention
 from the computer science community.
 In particular, even though every OMG modeling specification includes some
 kind of abstract syntax conformance criteria, none do so in terms of a
 specification for the program interface of a system implemention.
 This paper contributes to bridging this gap on two levels:
\end_layout

\begin_layout Enumerate
Defining an Application Program Interface (API) for a simplified OMG's MOF
 2.5 based on a normalized relational model.
 
\end_layout

\begin_layout Enumerate
Generating an Application Program Interface (API) from the simplified MOF
 abstract syntax metamodel of OMG UML 2.5.
\end_layout

\begin_layout Standard
The first step towards bridging the gap between the OMG and computer science
 culture is simplifying OMG's MOF 2.5
\end_layout

\begin_layout Section
An ontological normal form of a MOF
\end_layout

\begin_layout Standard
This section explains the rationale of each step involved in simplifying
 OMG's MOF into a irreducible, ontological, normal form information schema.
\end_layout

\begin_layout Subsection
Which of the three concepts is redundant?
\end_layout

\begin_layout Standard
Having established the redundancy of MOF Class, MOF Association and MOF
 Property for defining metamodels, which of these three can be eliminated?
 MOF Class is a first-class concept in metamodels because every element
 in a model must be an instance of at least one (meta)class defined in the
 metamodel that the model conforms to.
 Historically, there's been much debated about which of MOF Property and
 of MOF Association needs first-class status.
 MOF Property is a first-class concept in the Eclipse Modeling Framework
 (EMF).
 However, full support for binary MOF Associations requires a suitable EMF
 code generator represent them in EMF without loss of information.
 In terms of OMG's MOF 2.5 and EMF 2.12, there are three variations of binary
 MOF Associations to consider: 1) metaclass-owned association end properties;
 2) one association-owned end and one metaclass-owned end; 3) association-owned
 ends.
 EMF directly supports case (1) only: metaclass-owned association end properties
 are represented as opposite EMF 
\family typewriter
EReferences
\family default
 to update the opposite when one end is updated.
 The other two cases depend on the EMF code generator used.
 For example, the Eclipse UML code generator adds to each metaclass that
 is the type of an association-owned end property an EMF annotation that
 effectively acts as if the association-owned end property were instead
 owned by that metaclass.
 Since full association support depends on EMF code generation techniques,
 navigating models using the EMF 
\family typewriter
EObject
\family default
 and 
\family typewriter
EReference
\family default
 API is limited to the first case only.
 For cases (2,3), API-based navigation requires knowledge of the code generation
 encoding of association-owned ends, if they are represented at all
\begin_inset Foot
status open

\begin_layout Plain Layout
The default EMF code generator does not map association-owned end properties
\begin_inset CommandInset citation
LatexCommand cite
after "See section 6.4"
key "EMF"

\end_inset

.
\end_layout

\end_inset

 Since EMF is widely accepted as the de-facto open-source reference implementati
on of OMG's Essential MOF (EMOF) subset
\begin_inset CommandInset citation
LatexCommand cite
after "section 2.6.2"
key "EMF"

\end_inset

, the above analysis should suffice to claim that EMF is insufficient for
 code-generation agnostic API-based navigation of models according to all
 three cases of Complete MOF (CMOF) binary associations.
 Therefore, one must conclude that class+association are first-class concepts
 and that property isn't.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Deconstructing-the-concept"

\end_inset

Deconstructing the concept of CMOF property
\end_layout

\begin_layout Standard
MOF Property is not a first-class concept because it lacks conceptual unity.
 Indeed, a property can play different roles in a CMOF metamodel.
 In the absence of an official terminology, the terms used in this paper
 are underlined:
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:attribute"

\end_inset

A metaclass or datatype 
\bar under
attribute
\bar default
.
\end_layout

\begin_deeper
\begin_layout Standard
This case is outside the scope of the fundamental constructs of metamodels.
 An important simplification of current OMG practices is a clean separation
 of datatype libraries as a kind of model that can be used in other kinds
 of non-library models, i.e.
 metamodels, profiles and models that are instances of metamodels possibly
 extended with profiles.
 Clearly, metamodels and profiles need support for datatyped attributes;
 this is a minor technicality that will not be further elaborated in this
 paper.
 
\end_layout

\end_deeper
\begin_layout Enumerate
A metaclass 
\bar under
property
\bar default
.
\end_layout

\begin_deeper
\begin_layout Standard
(
\family typewriter
type
\family default
 is a metaclass)
\end_layout

\begin_layout Standard
In principle, CMOF constraints allow a metaclass to own a non-association
 end property typed by a metaclass.
 Without loss of generality, this paper considers this case to be a degenerate
 of the next case and can be refactored accordingly by explicitly defining
 an association.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:associationEnd"

\end_inset

A binary association 
\bar under
end
\bar default
.
\end_layout

\begin_deeper
\begin_layout Standard
(
\family typewriter
type
\family default
 is a metaclass; 
\family typewriter
aggregation=none|composite
\family default
; 
\family typewriter
isID=false
\family default
)
\end_layout

\begin_layout Standard
Since ends are an essential part of the definition of an association, the
 concept of MOF binary association is augmented to include the relevant
 characteristics of both ends (i.e., 
\family typewriter
type
\family default
, 
\family typewriter
lowerValue
\family default
, 
\family typewriter
upperValue
\family default
, 
\family typewriter
isOrdered
\family default
, 
\family typewriter
isUnique
\family default
,
\family typewriter
 isDerived
\family default
, 
\family typewriter
isDerivedUnion
\family default
, 
\family typewriter
isReadOnly
\family default
,
\family typewriter
 aggregation
\family default
,
\family typewriter
 subsettedProperty
\family default
, and 
\family typewriter
redefinedProperty
\family default
).
 Note that the last three characteristics are coupled between the two ends
\begin_inset Foot
status open

\begin_layout Plain Layout
See resolutions of issues 14993 and 14977 in UML 2.4.1
\begin_inset CommandInset citation
LatexCommand cite
key "UML 2.4.1 Report"

\end_inset

 for the last two.
 
\end_layout

\end_inset

:
\end_layout

\begin_layout Itemize

\family typewriter
aggregation
\family default
: Only one end may be 
\family typewriter
composite
\family default
.
\end_layout

\begin_layout Itemize

\family typewriter
subsettedProperty
\family default
: must be symmetric.
\end_layout

\begin_layout Itemize

\family typewriter
redefinedProperty
\family default
: must be accompanied by corresponding subsetting or redefinition at the
 other end.
\end_layout

\begin_layout Standard
Symmetric subsetting means that link instances of an association with subsetting
 ends must be also link instances of the other associations with the subsetted
 ends.
 This implies that an association with subsetting ends effectively specializes
 the associations whose ends are subsetted.
 Like subsetting, redefinition has a semantics of association specialization
 but with an additional forcing semantics in the contexts of the redefining
 ends: In such contexts, the redefining ends replace the redefined ends.
 This means that in such contexts, it is not possible to create link instances
 of the associations with redefined ends because such links must be instead
 instances of the association with redefining ends.
\end_layout

\end_deeper
\begin_layout Standard
The rest of this paper focuses only on case (3); the role of a property
 as an end of a binary association in a metamodel.
\end_layout

\begin_layout Subsection
Simplifying non-union derived association end properties
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename SimplifiedCMOF.svg
	width 15cm
	height 20cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Simplified CMOF metamodel"

\end_inset

Simplified CMOF metamodel.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The UML metamodel adopted a convention where non-union derived association
 end properties have a corresponding operation query
\begin_inset CommandInset citation
LatexCommand cite
after "section 6.4.1"
key "UML 2.5"

\end_inset

.
 The reckoning of this redundant representation is that the operation query
 enables specifying the OCL rule while the association end property enables
 specifying the availability of the derived property.
 This redundant modeling reflects historical practices that result in unecessary
 confusion and complexity.
 Often, only the metaclass-owned end is derived, the association-owned end
 isn't.
 This creates an unecessary source of confusion.
 Since nagivation is irrelevant for the purposes of OCL, it makes sense
 to treat such associations as if both ends are metaclass-owned and derived.
 Then, instead of duplicating each derived end with a corresponding operation
 query, it makes sense to delete the association altogether.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simplified CMOF metamodel"

\end_inset

 shows the result of carrying out these simplification steps to the subset
 of the UML 2.5 metamodel corresponding to the fundamental constructs in
 CMOF metamodels (i.e.
 class, association and association end property).
 Datatyped attribute properties are not shown as explained previously.
 The operation queries corresponding to deleted associations with derived
 ends are shown in red.
 Several metaclass attributes are no longer necessary and were deleted (Associat
ion::isDerived, Property::isDerived, StructuralFeature::isReadOnly)
\end_layout

\begin_layout Subsection
Deconstructing the concept of CMOF association
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename RefactoredCMOFAssociation.svg
	width 12cm
	height 20cm
	keepAspectRatio

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:RefactoredCMOF"

\end_inset

Refactored CMOF metamodel.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The key to understanding the simplification of CMOF binary association and
 of association end properties is to recognize that an association end property
 specifies two distinct aspects that are currently convolved in the concept
 of CMOF property: 1) a collection of values and 2) an operation for querying
 this collection.
 Unfortunate historical circumstances and a misplaced preoccupation with
 object-oriented programming contributed to muddling these two aspects under
 the bloated concept of CMOF property.
 The semantics of a property as a collection of values is explained in UML
 2.5.
 The semantics of a property as a query operation has been an important
 topic in the major revision of OCL 2.0, so much so that navigating across
 non-navigable ends has been a compliance point ever since.
 Unfortunately, OCL 2.0 was not ready when the OMG adopted major architecture
 changes from UML 1.x and MOF 1.x to UML 2.0 and MOF 2.0 in 2003, changes that
 were finalized in 2005 a year before OCL 2.0 in 2006.
 the major architecture changes from UML 1.x and MOF 1.x to UML 2.0 and MOF
 2.0 in 2003 and finalized in 2005.
 Perhaps the influence of the object-oriented programming paradigm from
 the simpler Essential MOF with classes and properties contributed to muddling
 these aspects.
 Indeed, avoiding strong references from metaclass-owned association end
 properties was historically used as the reason for making association ends
 owned by the association.
 It took several years until the publication of FUML 1.0 in 2010 before the
 emphasis was made on the fact that, at the model level, values of association
 end properties are set, cleared and updated not individually but rather
 via actions on link instances of associations.
 Unfortunately, even FUML 1.2.1 does provide symmetric support for instances
 of metaclasses and of associations as suggested by the MOF abstract semantics.
 Indeed, FUML restricts the ReadExtentAction to classifiers that are classes,
 not associations.
\end_layout

\begin_layout Standard
Separating collection from query aspect enables a significant simplification
 of CMOF, particularly since the query aspects can be fully generated from
 the collection aspects like Eclipse EMF code generation does for metamodel
 API and implementation.
 Thus, the refactored CMOF metamodel shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:RefactoredCMOF"

\end_inset

 separates the roles of a CMOF property as discussed in Sec.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Deconstructing-the-concept"

\end_inset

: DataProperty and AssociationEnd correspond respectively to cases 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:attribute"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:associationEnd"

\end_inset

.
 Since AssociationEnds are always attribute features of their owning Association
 because they cannot be members of two distinct namespaces like class-owned
 properties are in UML.
 Albeit a poorly understood consequence of UML 2.5 & MOF 2.5, a CMOF metamodel
 binary association is always directed from a source end to a target end
 according to a prioritized list of six criteria:
\end_layout

\begin_layout Enumerate
The target end is composite, the source end is not.
\end_layout

\begin_layout Enumerate
The source end is owned by the association, the target end by a metaclass.
\end_layout

\begin_layout Enumerate
Both ends are owned by the association, the source end is navigable, the
 target end isn't.
\end_layout

\begin_layout Enumerate
Both ends are not composite, the source end is unbounded, the target end
 has a finite upper bound.
\end_layout

\begin_layout Enumerate
The source end (resp.
 the target end) directly or indirectly subsets or redefines another source
 end (resp.
 target end).
\end_layout

\begin_layout Enumerate
The source and target ends are respectively the first and second properties
 in the ordered member end collection.
\end_layout

\begin_layout Standard
Instead of carrying this archaic criteria, the refactored CMOF metamodel
 explicitly differentiates at the metaclass level source and target association
 ends.
 Aggregation is only relevant for a target end property.
 Additional simplification stems from reflecting in the abstract syntax
 the difference that composite vs.
 reference (i.e.
 aggregation=none in UML2.5 terminology) makes for the semantics of associations.
 Finally, since generalization has different semantics for the kind of classifie
r involved, it is consequently specialized in the abstract syntax.
 This enables replacing the complex UML2.5 notions of property subsets and
 redefinitions with a much simpler boolean flag corresponding to the semantics
 of symmetric subsetting and of redefinition forcing: the source (resp.
 target) restriction flag on AssociationGeneralization indicates whether
 the generalization corresponds to the weak case of subsetting (i.e., restriction
 = false; the value of the specialized end is existentially constrained
 to be a subset of the value of the general end) or to the strong case of
 redefinition with forcing semantics (i.e., restriction = true; the value
 of the specialized end universally restricts the value of the general end).
 
\end_layout

\begin_layout Section
Contributions
\end_layout

\begin_layout Standard
This paper makes three significant contributions towards addressing significant
 issues with the OMG UML 2.5 specification:
\end_layout

\begin_layout Enumerate
Define a tool-neutral Application Program Interface (API) adaptable to tools
 claiming abstract syntax conformance to OMG UML 2.5.
\end_layout

\begin_deeper
\begin_layout Standard
Unfortunately, the OMG stopped the UML 1.x practice of publishing revisions
 of UML 2 with an 
\begin_inset Quotes eld
\end_inset

Interface Definition Language
\begin_inset Quotes erd
\end_inset

 (IDL) API.
 Consequently, the OMG UML 2.5 specification lacks an objective basis for
 assessing whether 
\begin_inset Quotes eld
\end_inset

a tool demonstrating abstract syntax conformance provides a user interface
 and/or API that enables instances of concrete UML metaclasses to be created,
 read, updated, and deleted.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
This paper contributes a novel approach for generating and specifying a
 strongly type-safe abstract syntax API for OMG UML 2.5 parameterized by
 a tool-specific adapter for an existing implementation of UML 2.5.
 This API has been adapted for two existing UML 2.5 tools: NoMagic's MagicDraw
 version 18.0 and Eclipse UML version 5.0.
 The paper describes an approach for generating a suite of abstract syntax
 conformance tests that cold be used for objectively assessing the compliance
 of OMG UML 2.5 tool implementations and for objectively assessing model
 interchange via tool-specific API adapters instead of via external serializatio
n as done before.
\end_layout

\end_deeper
\begin_layout Enumerate
Define a set of 4th normal form database tables and relationships enabling
 a radically simpler tabular serialization of UML models compared to the
 complex tree serialization of UML models based on OMG's XMI 2.5 specification.
\end_layout

\begin_deeper
\begin_layout Standard
For serialization, the OMG chose to represent the abstract syntax containment
 organization of a UML model as an XML tree.
 This seems a sensible choice given that a tree precisely captures the key
 architecture principle of single element ownership that applies to all
 OMG modeling languages, including UML.
 The complexity arises from two factors: 1) logically, a given tuple of
 owning element and owned element can be a link instance of multiple composite
 associations defined in the UML metamodel and 2) logically, the lack of
 clarity in the criteria for determining which composite association requires
 a serialization as an XML nested element from others requring serialization
 as an XML element reference.
 
\end_layout

\begin_layout Standard
From a database perspective, the abstract syntax containment organization
 of a UML model is a materialized view of the information.
 The UML metamodel (a materialized view) has information redundancy that
 induces serialization redundancy: for example, every class-owned association
 end in the UML metamodel is both an attribute of its owning class and a
 member end of its association.
 Much of the complexity in OMG's XMI specification is an accidental consequence
 of trying to avoid unecessary redundant serialization.
 Normalizing the UML metamodel removes all information redundancy: for example,
 every association owns both ends.
 This paper presents a 4th-normal form of a UML metamodel where every metaclass
 is reduced to a table with only data property attributes and every association
 is reduced to a relationship table with an ordering data property attribute
 if one association end property is ordered.
 For a large model of a space mission (over 0.5 million UML elements), normal
 form serialization is considerably faster than the native tool-specific
 XMI tree serialization.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Define a description logic formalization of UML's abstract syntax for reasoning
 about UML syntax precisely instead of informally per the UML specification.
\end_layout

\begin_deeper
\begin_layout Standard
UML provides a rich vocabulary for describing the structure and behavior
 of arbitrary systems.
 The UML vocabulary is extensible to accomodate domain-specific language
 modeling needs with the concept of UML profile extensions of the UML metamodel
 such as the Systems Modeling Language (SysML) for the domain of systems
 engineering.
 A typical concern in the development of a UML profile extension of UML/SysML
 for a domain-specific Model-Based Systems Engineering (MBSE) methodology
 is whether the intended expressiveness of the extended vocabulary in the
 specific domain can be represented as a well-formed UML/SysML model with
 the domain-specific profile applied.
 A serious concern is the limitations from the UML abstract syntax that
 prevent using the UML vocabulary for reasonable domain-specific modeling
 purposes.
 For example, the 6 of the 12 significant issues fixed in the OMG SysML
 1.4 revision provide support for explicitly representing in the abstract
 syntax notions of scope and context that are currently implicit in the
 UML 2.5 abstract syntax.
 Unfortunately, the SysML 1.4 specification does not address the logical
 implications for managing the SysML extensions when the underlying UML
 elements are created, read, updated or deleted.
 This paper presents a simple strategy for leveraging a 4th normal form
 definition of the abstract syntax of UML and profile extensions such as
 SysML as the basis for ontological reasoning about extended UML models.
\end_layout

\end_deeper
\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
This research was carried out at the Jet Propulsion Laboratory, California
 Institute of Technology, under a contract with the National Aeronautics
 and Space Administration.
\end_layout

\begin_layout Standard
Reference herein to any specific commercial product, process, or service
 by trade name, trademark, manufacturer, or otherwise, does not constitute
 or imply its endorsement by the United States Government or the Jet Propulsion
 Laboratory, California Institute of Technology.
\end_layout

\begin_layout Standard
The author expresses gratitude to many colleagues at the Jet Propulsion
 Laboratory's Integrated Model-Centric Engineering project and the Laboratory
 for Reliable Software, in particular, M.
 Elaasar, K.
 Havelind, S.
 Herzig, S.
 Jenkins and R.
 Kumar, and to many current and past task force colleagues at the Object
 Management Group (OMG), in particular, Y.
 Bernard, C.
 Bock, R.
 Burkhart, S.
 Cook, S.
 Friedenthal, M.
 Elaasar, M.
 Koethe, P.
 Rivett, E.
 Seidewitz and B.
 Selic.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "TypesAndProgrammingLanguages"

\end_inset

B.
 C.
 Pierce, 
\begin_inset Quotes eld
\end_inset

Types and Programming Languages
\begin_inset Quotes erd
\end_inset

, 2002.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "EMF"

\end_inset

D.
 Steinberg, F.
 Budinsky, M.
 Paternostro, E.
 Merks, 
\begin_inset Quotes eld
\end_inset

EMF Eclipse Modeling Framework
\begin_inset Quotes erd
\end_inset

, 2nd edition, Addison-Wesley, 2008.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "MOF 2.5"

\end_inset

Object Management Group, 
\begin_inset Quotes eld
\end_inset

Meta-Object Facility Core Specification
\begin_inset Quotes erd
\end_inset

, version 2.5, formal/2015-06-05, 2015.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "UML 2.4.1 Report"

\end_inset

Object Management Group, 
\begin_inset Quotes eld
\end_inset

Report of the UML version 2.4.1 Revision Task Force
\begin_inset Quotes erd
\end_inset

, ptc/2011-01-19, 2010.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "UML 2.5"

\end_inset

Object Management Group, 
\begin_inset Quotes eld
\end_inset

Unified Modeling Language version 2.5
\begin_inset Quotes erd
\end_inset

, formal/2015-03-01, 2015.
\end_layout

\end_body
\end_document
